## 目录

### 前言

### 第1部分：异步编程基础

#### 1. 并发与异步编程：详细概述

- **技术要求**
- 多任务处理的进化历程
- 非抢占式多任务
- 抢占式多任务
- 超线程
- 多核处理器
- 你真的是在写同步代码吗？
- 并发与并行
- 我使用的思维模型
- 让我们画出一些与进程经济学的平行关系
- 并发与I/O的关系
- 那操作系统提供的线程怎么办？
- 选择合适的参考框架
- 异步与并发
- 操作系统的角色
- 从操作系统的视角看并发
- 与操作系统合作
- 与操作系统通信
- CPU与操作系统
- 走进兔子洞
- CPU是如何防止我们访问不该访问的内存的？
- 难道我们不能直接在CPU中修改页表吗？
- 中断、固件和I/O
    - 简化概述
    - 中断
    - 固件

#### 总结


## 异步与并发

- 操作系统的角色
- 从操作系统的角度看并发
- 与操作系统合作
- 与操作系统通信
- CPU与操作系统
- 走进兔子洞
- CPU是如何防止我们访问不该访问的内存的？
- 难道我们不能直接在CPU中修改页表吗？
- 中断、固件和I/O
    - 简化概述
    - 中断
    - 固件

#### 总结

---

## 2. 编程语言如何建模异步程序流

- **定义**
- 线程
- 操作系统提供的线程
- 创建新线程需要时间
- 每个线程有自己的栈
- 上下文切换
- 调度
- 将异步操作与操作系统线程解耦的优点
- 示例
- 纤程和绿色线程
- 每个栈有固定的空间
- 上下文切换
- 调度
- 外部函数接口（FFI）
- 基于回调的方法
- 协程：承诺和未来
- 协程与async/await
- **总结**

---

## 3. 理解操作系统支持的事件队列、系统调用和跨平台抽象

- **技术要求**
- 运行Linux示例
- 为什么使用操作系统支持的事件队列？
- 阻塞I/O
- 非阻塞I/O
- 通过epoll/kqueue和IOCP进行事件排队
- 基于就绪的事件队列
- 基于完成的事件队列
- epoll, kqueue和IOCP
- 跨平台事件队列
- 系统调用、FFI和跨平台抽象
## 3. 理解操作系统支持的事件队列、系统调用和跨平台抽象

- **技术要求**
- 运行Linux示例
- 为什么使用操作系统支持的事件队列？
- 阻塞I/O
- 非阻塞I/O
- 通过epoll/kqueue和IOCP进行事件排队
- 基于就绪的事件队列
- 基于完成的事件队列
- epoll, kqueue和IOCP
- 跨平台事件队列
- 系统调用、FFI和跨平台抽象
    - 最低层次的抽象
    - 下一层次的抽象
    - 最高层次的抽象

#### 总结

---

## Part 2: 事件队列与绿色线程

### 4. 创建你自己的事件队列

- **技术要求**
- 设计与epoll简介
- 所有I/O操作都阻塞吗？
- ffi模块
- 位标志与位掩码
- 水平触发与边缘触发事件
- Poll模块
- 主程序
- **总结**

### 5. 创建我们自己的纤程

- **技术要求**
- 如何将仓库与本书一起使用
- 背景信息
    - 指令集、硬件架构与ABI
    - x86-64的System V ABI
    - 简要介绍汇编语言
    - 一个我们可以构建的示例
- 设置我们的项目
- Rust内联汇编宏简介
- 运行我们的示例
- 堆栈
    - 堆栈是什么样的？
    - 堆栈大小
- 实现我们自己的纤程
    - 实现运行时
    - Guard、skip和switch
## ABIs
- x86-64的System V ABI
- 汇编语言简要介绍
- 一个我们可以构建的示例
- 设置我们的项目
- Rust内联汇编宏简介
- 运行我们的示例
- 堆栈
    - 堆栈是什么样的？
    - 堆栈大小
- 实现我们自己的纤程
    - 实现运行时
    - Guard、skip和switch函数
- 完成的思考
- **总结**

---

## Part 3: Rust中的Futures与async/await

### 6. Rust中的Futures

- 什么是Future？
- Leaf Futures
- 非Leaf Futures
- 异步运行时的思维模型
- Rust语言和标准库的处理
- I/O与CPU密集型任务
- **总结**

### 7. 协程和async/await

- **技术要求**
- 无栈协程简介
- 手写协程的示例
- Futures模块
- HTTP模块
- 所有Future都必须是惰性的吗？
- 创建协程
- async/await
- coroutine/wait
- corofy——协程预处理器
- b-async-await——协程/等待转换示例
- c-async-await——并发Future
- 最后的思考
- **总结**

### 8. 运行时、Wakers和反应器-执行器模式

- **技术要求**
- 运行时简介以及为什么需要它们
- 反应器和执行器
- 改进我们的基本示例
- 设计
- 修改当前实现
- 创建一个合适的运行时
- 步骤1 - 改进我们的...
### 步骤 2 - 实现一个合适的执行器
### 步骤 3 - 实现一个合适的反应器
- 实验我们的新运行时
- 一个使用并发的示例
- 同时并行运行多个Future
- **总结**

---

### 9. 协程、自引用结构体与Pinning

- **技术要求**
- 改进我们的示例1 – 变量
- 设置基础示例
- 改进我们的基础示例
- 改进我们的示例2 – 引用
- 改进我们的示例3 – 这…不好…
- 发现自引用结构体
- 什么是move？
- Rust中的Pinning
- Pinning的理论
- 定义
- 固定到堆上
- 固定到栈上
- Pin投影与结构化Pinning
- 改进我们的示例4 – Pinning来救场
- future.rs
- http.rs
- Main.rs
- executor.rs
- **总结**

---

### 10. 创建你自己的运行时

- **技术要求**
- 设置我们的示例
- main.rs
- future.rs
- http.rs
- executor.rs
- reactor.rs
### 实验我们的运行时
- **异步Rust的挑战**
- 显式与隐式反应器实例化
- 人体工程学与效率及灵活性
- 每个人都同意的常见特性
- 异步的drop
- 异步Rust的未来
- **总结**

### 尾声

### 索引

### 你可能喜欢的其他书籍
