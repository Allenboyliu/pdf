这本书的内容涵盖了很多方面，并尝试对这些内容进行深入探讨。书中的内容编写方式旨在让你可以逐章学习，但也预期有些读者只对其中的一部分内容感兴趣。

第一章：基础 – 机器架构与开始使用 Rust
本章讨论了现代 CPU 架构，特别是 x86 和 ARM 架构。这两种架构将是本书的重点。假设读者已经对 Rust 有一定了解，但我们也会讨论如何验证你的安装是否按预期工作。

第二章：顺序 Rust 性能与测试
本章介绍了如何检查 Rust 程序的性能。计算机硬件的细节在这方面尤其重要：缓存交互、内存布局以及如何利用问题领域的特性对编写快速程序至关重要。然而，如果结果不准确，再快也没有意义。本章还重点讲解了 Rust 中的测试。

第三章：Rust 内存模型 – 所有权、引用和操作
本章讨论了 Rust 的内存模型，特别是 Rust 如何实现内存安全，语言如何通过一些约束来保证安全，以及这些约束如何影响基础类型的实现。读者将在本章结束时理解借用检查器及其工作原理。

第四章：Sync 和 Send – Rust 并发的基础
本章是介绍并发概念的第一章，讨论了 Sync 和 Send trait，为什么它们存在以及它们的含义。本章结束时将通过一个具体的多线程 Rust 程序来演示这些概念。

第五章：锁 – Mutex、Condvar、Barrier 和 RWLock
本章介绍了 Rust 程序员可以使用的粗粒度同步方法。每种方法都逐一进行讲解，并通过工业 Rust 项目（hopper）中的实际应用进行演示。粗粒度同步方法将在后续的小项目和数据结构中详细展开。

第六章：原子操作 – 同步的基本原语
本章介绍了通过所有现代 CPU 支持的原子操作来实现精细同步。这是一个非常难的主题，我们深入探讨了原子编程及其方法。本章涵盖了无锁的原子数据结构和生产级代码库。读者将在本章中构建第 5 章中看到的许多粗粒度同步机制。

第七章：原子操作 – 安全回收内存
本章详细讨论了原子编程中的一个关键难题——如何安全地回收内存。重点讨论了三种主要方法：引用计数、危险指针、基于时期的回收，并深入研究了适用于生产的代码库。特别是，讨论了 Crossbeam 的详细实现。

第八章：高级并行性 – 线程池、并行迭代器和进程
本章讲解了线程池的实现，并阐明了实现线程池的动机。掌握这些知识后，本章将探讨 Rayon 项目，并在一个从简单数据并行性中受益的复杂项目中使用它并行性 – 线程池、并行迭代器和进程，通过将 C 代码嵌入其中
第九章：本章介绍了线程池、并行迭代器和进程的并行性概念，并讨论了如何将 C 代码嵌入其中。还讲解了 rlua 项目，这是一个方便的库，用于将 Lua 程序嵌入 Rust 程序。章节最后介绍了如何将 Rust 编译成可以嵌入 C、Python 和 Erlang 项目中的方式。

第十章：未来主义 – 近期 Rust 发展
本章结束了全书，讨论了与并行编程相关的近期 Rust 语言变化以及其他一些杂项问题。

关于作者
Daniel Durante 是一个热衷于喝咖啡和烘焙咖啡的爱好者，也是一名摩托车骑士、弓箭手、焊工和木匠，在没有编程的时光里，他享受这些活动。自 12 岁起，他就开始从事网页编程和嵌入式编程，使用 PHP、Node.js、Golang、Rust 和 C 等语言。他曾参与开发过文本型浏览器游戏，曾有超过百万活跃玩家；也开发过为 CNC 机器设计的二进制装箱软件；从事过 Cortex-M 和 PIC 电路的嵌入式编程；开发过高频交易应用；并为 Node.js 最古老的 ORM 之一（SequelizeJS）做出了贡献。

他还为 Packt 出版社审阅了以下书籍：

PostgreSQL 开发者指南
PostgreSQL 9.0 高级节点食谱
致谢
感谢我的父母、兄弟和朋友们，他们容忍我每天坐在电脑前疯狂编程。如果没有他们的耐心、指导和爱，我今天无法走到这里。

Packt 正在寻找像您这样的作者

如果您有兴趣成为 Packt 出版社的作者，请访问 authors.packtpub.com 并立即申请。我们已经与成千上万的开发者和技术专业人士合作，帮助他们将自己的见解与全球技术社区分享。您可以提交一般申请，申请我们正在招聘作者的热门话题，或者提交您自己的想法。


# 目录

- 书名页
- 版权和致谢
- 《Hands-On Concurrency with Rust》
- 献辞
- Packt Upsell
- 为什么订阅？
- PacktPub.com
- 贡献者
- 关于作者
- 关于审阅者
- Packt 正在寻找像您这样的作者
- 前言
    - 本书适合谁
    - 本书内容
    - 如何最大限度地利用本书
    - 下载示例代码文件
    - 使用的约定
    - 联系我们
    - 评价
- 预备知识 - 机器架构和 Rust 入门
    - 技术要求
    - 机器
    - CPU
    - 内存和缓存
    - 内存模型
- 设置环境
    - 有趣的部分
    - 调试 Rust 程序
- 总结
- 进一步阅读
- 顺序 Rust 性能和测试
    - 技术要求
    - 收益递减
    - 性能
    - 标准库 HashMap
    - 简单的 HashMap
    - 使用 QuickCheck 进行测试
    - 使用 American 测试

# 目录

- Fuzzy Lop
- 使用 Criterion 进行性能测试
- 使用 Valgrind 套件进行检查
- 使用 Linux perf 进行检查
- 更好的简单 HashMap
- 总结
- 进一步阅读

## Rust 内存模型 – 所有权、引用和操作
- 技术要求
- 内存布局
- 内存指针
- 内存的分配与释放
- 类型的大小
- 静态与动态调度
- 零大小类型
- 被 Box 包装的类型
- 自定义分配器
- 实现
    - Option
    - Cell 和 RefCell
    - Rc
    - Vec
- 总结
- 进一步阅读

## Sync 和 Send – Rust 并发基础
- 技术要求
- Sync 和 Send
- 线程竞态
## Ring 的缺陷
- 回到安全性
- 排除法的安全性

## 使用 MPSC
- 一个遥测服务器

## 总结
- 进一步阅读

## 锁 – Mutex、Condvar、Barriers 和 RWLock
- 技术要求
- 读多写独占锁 – RwLock
- 条件改变时阻塞 – condvar
- 等待所有成员到齐 – barrier
- 更多的 mutex、condvar 和其他相关实现
- 火箭准备问题
- 绳索桥问题

## Hopper — MPSC 特化
- 问题描述
- Hopper 的使用
- Hopper 的概念视图
- 双端队列（deque）
- 接收者（Receiver）
- 发送者（Sender）

## 测试并发数据结构
- 使用 QuickCheck 和循环
- 使用 AFL 寻找崩溃
- 性能基准测试

## 总结
- 进一步阅读
## Atomics – 同步的原语

### 技术要求

- 线性化
- 内存排序 – happens-before 和 synchronizes-with
  - Ordering::Relaxed
  - Ordering::Acquire
  - Ordering::Release
  - Ordering::AcqRel
  - Ordering::SeqCst

### 构建同步

- Mutexes
- 比较并设置 mutex

### 一个错误的原子队列

- 纠正错误队列的选项
- 信号量
  - 二进制信号量，或者更节省的 mutex

## 总结
- 进一步阅读

## Atomics – 安全地回收内存

### 技术要求

- 内存回收的方法
- 引用计数
  - 权衡

### 危险指针

- 危险指针 Treiber 栈
- Nightly 的危险
- 锻炼危险指针 Treiber 栈
- 权衡

### 基于时期的回收

- 基于时期的 Treiber
## stack

- crossbeam_epoch::Atomic
- crossbeam_epoch::Guard::defer
- crossbeam_epoch::Local::pin

### 锻炼基于时期的 Treiber 栈

- 权衡

## 总结
- 进一步阅读

## 高级并行性 – 线程池、并行迭代器和进程

### 技术要求

- 线程池
- Slowloris – 攻击每连接一个线程的服务器
  - 服务器
  - 客户端
  - 线程池服务器

### 查看线程池

- 以太网嗅探器

### 迭代器

- Smallcheck 迭代

### rayon – 并行迭代器

- 数据并行性与操作系统进程 – 演化中的 corewars 玩家
  - Corewars

### Feruscore – Corewars 演化器

- 表示领域
- 探索源代码
- 指令
- 个体
- 突变与繁殖
## SIMD

- 十六进制编码

## Futures 和 async/await

- 特化

## 有趣的项目

- 模糊测试

## Seer，一个 Rust 的符号执行引擎

## 社区

### 我应该使用 `unsafe` 吗？

## 总结
- 进一步阅读

## 其他您可能感兴趣的书籍

- 留下您的评论，让其他读者知道您的想法
